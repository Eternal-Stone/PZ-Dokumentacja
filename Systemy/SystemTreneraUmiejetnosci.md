# System Trenera Umiejętności

Umiejętności, których gracz nauczył się podczas pobytu w grze i rozwoju swojej klasy, mogą zostać podniesione na wyższy poziom poprzez terminowanie u mistrza. Terminowanie u mistrza niesie za sobą konsekwencję płacenia za szkolenie.

Ulepszając umiejętności, gracz przechodzi przez mini-grę dla każdej z nich. Po ich ukończeniu umiejętność jest ulepszana.

## Ulepszanie umiejętności

Mini-gra polega na poprowadzeniu kursora po poprawnym kształcie. Kształt będzie zależny od trenowanej umiejętności i w jakimś stopniu do niej nawiązuje. Im większa precyzja wykonania mini-gry, tym lepiej postać się umiejętności.

Prób nauczenia jest nieskończenie wiele, jednak za każdą próbę należy zapłacić trenerowi złotem.

**Progi precyzji**:

- 0% - 50%: nauka nieudana, wymagane ponowne rozpoczęcie.
- 50% - 75%: nauczono się umiejętności w stopniu poprawnym.
- 75% - 82%: nauczono się umiejętności w stopniu dobrym.
- 82% - 90%: nauczono się umiejętności w stopniu bardzo dobrym.
- 90% - 95%: nauczono się umiejętności w stopniu celującym.
- 95% - 98%: osiągnięto mistrzostwo umiejętności.
- 98% - 100%: osiągnięto poziom Arcymistrza umiejętności.

Nauczyciel może ulepszać umiejętność kilkakrotnie - raz na 10 poziomów. Oznacza to, że gracz może ulepszyć umiejętność 8 razy poprzez swoje doświadczenie, gdyż maksymalny poziom to **80**.

Ostatnie 7 ulepszeń gracz jest w stanie uzyskać kończąc drogę do legendy. Są to questy ukierunkowane na znalezienie Legendarnych Mistrzów. Ci na końcu wręczają graczowi swoje **Legendarne Księgi Umiejętności**.

## Epicki poziom umiejętności

Poprzez system riftów gracz może uzyskać dostęp do ostatniego poziomu ulepszenia umiejętności, tworząc **Księgi Światowe**. Te księgi mogą ulepszyć umiejętność z 15 poziomu na poziom Legendarny. Każda nauka skilla wygląda dokładnie tak samo jak wcześniej.

## System nauki precyzji w rozróżnieniu na klasy

### Berserker

Styl: Surowa siła, brutalność, agresja. Kształty nawiązujące do chaosu i niszczenia.

1. Zygzak w formie błyskawicy.
2. Rozchodząca się gwiazda (eksplozja).
3. Ostre „V” skierowane w dół.
4. Prosta linia z ostrym zakończeniem na jednym końcu.
5. Spirala z przecięciem w środku.
6. Trójkąt z wygiętymi rogami (symbol siły).
7. Litera „W” z dodatkowymi ostrymi liniami.
8. Kwadrat z przecięciem na skos.
9. Półokrąg z liniami promieniującymi na zewnątrz.
10. Symbol piły (zębaty okrąg).
11. Krzyż („X”) z wydłużonymi ramionami.
12. Prostokąt z wycięciem pośrodku.
13. Fala w kształcie litery „S”.
14. Kropla krwi (okrąg z ostrym końcem).
15. Symbol topora (trójkąt z przedłużeniem linii).

### Rycerz

Styl: Stabilność, symetria, obrona. Kształty odzwierciedlające porządek i umocnienia.

1. Prostokąt symbolizujący tarczę.
2. Okrąg z centralnym punktem (symboliczna tarcza ochronna).
3. Pionowa linia z odchodzącymi ramionami (symbol „T”).
4. Trójkąt skierowany w dół.
5. Kwadrat w kwadracie (podwójna ochrona).
6. Krzyż („+”) z krótszymi ramionami.
7. Prostokąt z łukiem na górze (symbol hełmu).
8. Kontur tarczy (owal z wycięciem).
9. Pozioma linia z łukiem nad nią.
10. Symetryczne „W” przypominające mury.
11. Gwiazda z pięcioma ramionami.
12. Litera „H” z wygiętymi liniami.
13. Spiralny okrąg (symbol wzmocnienia).
14. Linia prostokątna zakończona strzałkami po obu końcach.
15. Symbol łuku (półkole z linią).

### Gladiator

Styl: Dynamika, szybkość, precyzja. Kształty smukłe i agresywne, ale bardziej eleganckie.

1. Płynna linia w kształcie litery „S”.
2. Ostry łuk z powrotem w dół (półksiężyc).
3. Litera „Z” o ostrych rogach.
4. Koło z przecięciem w środku.
5. Podwójna spirala (precyzja).
6. Krzyżujące się linie tworzące „X”.
7. Linia tworząca wężowy ruch.
8. Smukły trójkąt skierowany w górę.
9. Symbol pióra (linia z odgałęzieniami).
10. Prosta linia zakończona trójkątami.
11. Pionowe „8” (symbol szybkości).
12. Rozchodzące się strzałki z jednego punktu.
13. Spirala kończąca się ostrym punktem.
14. Łuk zakończony haczykiem.
15. Gwiazda z sześcioma ramionami.

### Łowca

Styl: Natura, precyzja, współpraca z towarzyszem. Kształty inspirowane zwierzętami i ich ruchami.

1. Zygzak przypominający ślad zwierzęcych pazurów.
2. Strzałka skierowana w górę.
3. Symbol łapy (trójkąt z odchodzącymi liniami).
4. Kontur oka (owal z punktem w środku).
5. Linia falująca jak liść na wietrze.
6. Prosta linia z rozchodzącymi się odgałęzieniami (gałąź).
7. Trójkąt z zaokrąglonymi krawędziami.
8. Łuk z przecięciem pośrodku.
9. Gwiazda z czterema długimi promieniami.
10. Koło z odchodzącymi krótkimi liniami (symbol słońca).
11. Fala przypominająca rzekę.
12. Okrąg z odcięciem na górze.
13. Liść (kontur w kształcie „V” z falą w środku).
14. Kontur pazura (krótkie, ostre linie ułożone w okrąg).
15. Symbol strzały z rozciągniętym łukiem.

### Magowie

Styl: Magiczny, złożony, inspirujący. Kształty odzwierciedlające żywioły i mistycyzm.

1. Spirala symbolizująca magię.
2. Gwiazda z ośmioma ramionami.
3. Okrąg przecięty poziomą linią (symbol pełni i pustki).
4. Fala przypominająca płomień (ognisty mag).
5. Koło z liniami jak promienie światła (słońce).
6. Pionowe linie w formie kropli (woda, lód).
7. Trójkąt skierowany w górę (ogień).
8. Symbol „Z” z zaokrąglonymi rogami (błyskawica).
9. Fala w kształcie litery „W” (powietrze).
10. Owalny kształt przypominający kamień (ziemia).
11. Gwiazda z liniami przechodzącymi przez środek.
12. Kontur księżyca (półokrąg z odcięciem).
13. Symbol ognia (płomień ze smukłym końcem).
14. Linia przypominająca tornado (powietrze).
15. Kontur diamentu (ostrzejsza forma kryształu).

### Kapłani i Uzdrowiciele

Styl: Światło, harmonia, uzdrowienie. Kształty symetryczne i łagodne.

1. Symbol aureoli (okrąg z odchodzącymi liniami).
2. Gwiazda z miękkimi liniami.
3. Krzyż z zaokrąglonymi ramionami.
4. Okrąg z falą w środku (symbol spokoju).
5. Serce z odchodzącymi liniami.
6. Półokrąg z punktami na końcach.
7. Linia tworząca literę „C” z ozdobą.
8. Spirala zakończona miękkim punktem.
9. Fala w kształcie litery „U”.
10. Symetryczny liść.
11. Prosta linia z okręgiem na końcu.
12. Trzy równoległe linie (symbol harmonii).
13. Owal z pionowym przecięciem.
14. Rozchodzące się promienie z centralnego punktu.
15. Symbol błogosławieństwa (dwa półokręgi skierowane ku sobie).

### Druid

Styl: Natura, harmonia z przyrodą, organiczne kształty. Inspiracja roślinnością, zwierzętami i cyklami natury.

1. Liść: Kontur w kształcie „V” z łagodnym wygięciem.
2. Spirala: Zwijająca się w kierunku środka (symbol cyklu natury).
3. Korzenie: Rozgałęziające się linie przypominające drzewo.
4. Okrąg z wcięciem na dole: Symbol słońca nad horyzontem.
5. Fala przypominająca rzekę: Delikatne, płynne linie.
6. Półokrąg z promieniami: Symbolizujący księżyc i jego blask.
7. Gałąź: Linia z krótkimi odgałęzieniami na obu końcach.
8. Symetryczne „W”: Ostre linie, przypominające góry.
9. Kontur zwierzęcego pazura: Krótkie, łukowate linie.
10. Owal z wewnętrzną spiralą: Nawiązanie do cyklu wzrostu.
11. Symbol nasiona: Dwa półokręgi skierowane ku sobie.
12. Zygzak imitujący piorun: Natura w jej dzikim żywiole.
13. Koło z wewnętrznymi odchodzącymi liniami: Drzewo życia.
14. Kontur kwiatu: Prosty kształt pięciopłatkowego kwiatu.
15. Symbol fali w kształcie litery „S”: Wiatr lub strumień.

### Gildie i Klasy Specjalne (dla graczy w roli liderów lub strategicznych postaci)

Styl: Przywództwo, organizacja, symbole wskazujące na status i siłę. Geometryczne i eleganckie formy.

1. Korona: Kontur trójkątów ułożonych w półkole.
2. Okrąg przecięty na cztery części: Symbol współpracy i jedności.
3. Trójkąt z podwójną ramą: Symbol struktury i hierarchii.
4. Gwiazda z sześcioma ramionami: Subtelny symbol prestiżu.
5. Prosty herb: Prostokąt przecięty na pół.
6. Symbol tarczy z wewnętrzną literą „G”: Nawiązanie do gildii.
7. Linia ze strzałkami skierowanymi w obu kierunkach: Współpraca i strategia.
8. Skrzyżowane linie tworzące „X”: Wskazanie celu lub miejsca.
9. Koło z odchodzącymi prostymi liniami: Symbol słonecznego lidera.
10. Wzór labiryntu: Geometryczna spirala.
11. Symbol strzały skierowanej w górę: Postęp i rozwój.
12. Diamentowy kształt z odciętymi rogami: Elegancja i siła.
13. Dwie równoległe linie z przecięciem pośrodku: Most łączący strony.
14. Prosty kwadrat z odchodzącymi łukami: Twierdza lub bastion.
15. Gwiazda z okręgiem w środku: Centrum uwagi i prestiżu.

## Propozycja programu realizującego dany problem

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>  // For rand() and srand()
#include <ctime>    // For time()


// Enum for different classes
enum class ClassType {
    Berserker,
    Knight,
    Gladiator,
    Hunter,
    Mage,
    Priest,
    Druid,
    GuildLeader
};


// Enum for skill types
enum class SkillCategory {
    Offensive,
    Defensive,
    Support,
    Other
};


// Struct to represent a Skill
struct Skill {
    std::string name;
    SkillCategory category;
    int level;             // Current level (max 80)
    double baseValue;     // Base value for the skill
    double bonusValue;    // Bonus value from training
    int upgradeCount;     // Number of upgrades (max 8 before Legendary)
   
    Skill(std::string skillName, SkillCategory skillCategory, double base)
        : name(skillName), category(skillCategory), level(0), baseValue(base), bonusValue(0.0), upgradeCount(0) {}
};


// Struct to represent a Character
struct Character {
    std::string name;
    ClassType classType;
    double gold;
    std::vector<Skill> skills;
   
    Character(std::string charName, ClassType cls, double initialGold)
        : name(charName), classType(cls), gold(initialGold) {}
};


skill trainer class


class SkillTrainer {
public:
    // Precision thresholds and corresponding mastery levels
    struct MasteryLevel {
        double minPrecision;
        std::string description;
    };
   
    SkillTrainer() {
        // Initialize mastery levels
        masteryLevels = {
            {0.0, "Failed. Try again."},
            {50.0, "Correct"},
            {75.0, "Good"},
            {82.0, "Very Good"},
            {90.0, "Aimed"},
            {95.0, "Master"},
            {98.0, "Arch-Master"},
            {100.0, "Grand Arch-Master"}
        };
    }
   
    // Function to train a skill
    bool TrainSkill(Character& character, int skillIndex, double precision) {
        if (skillIndex < 0 || skillIndex >= character.skills.size()) {
            std::cout << "Invalid skill index.\n";
            return false;
        }
       
        Skill& skill = character.skills[skillIndex];
       
        // Check if skill can be upgraded
        if (skill.level >= 80) {
            std::cout << "Skill '" << skill.name << "' has reached maximum level.\n";
            return false;
        }
       
        if (skill.upgradeCount >= 8) {
            std::cout << "Skill '" << skill.name << "' has reached maximum upgrades. Complete legendary quests to further enhance.\n";
            return false;
        }
       
        // Determine gold cost (example: 100 gold per attempt, can be adjusted)
        double goldCost = 100.0;
        if (character.gold < goldCost) {
            std::cout << "Not enough gold to train. Required: " << goldCost << ", Available: " << character.gold << "\n";
            return false;
        }
       
        // Deduct gold
        character.gold -= goldCost;
        std::cout << character.name << " paid " << goldCost << " gold to train skill '" << skill.name << "'.\n";
       
        // Determine mastery based on precision
        std::string masteryDesc = DetermineMastery(precision);
        std::cout << "Precision Achieved: " << precision << "% - " << masteryDesc << "\n";
       
        if (precision >= 50.0) {
            // Successful training
            skill.level += 1;
            skill.upgradeCount += 1;
           
            // Apply bonus based on mastery
            ApplyMasteryBonus(skill, precision);
           
            std::cout << "Skill '" << skill.name << "' leveled up to " << skill.level << ".\n";
            return true;
        } else {
            // Failed training
            std::cout << "Training failed. Try again.\n";
            return false;
        }
    }
   
private:
    std::vector<MasteryLevel> masteryLevels;
   
    // Function to determine mastery description
    std::string DetermineMastery(double precision) {
        for (auto it = masteryLevels.rbegin(); it != masteryLevels.rend(); ++it) {
            if (precision >= it->minPrecision) {
                return it->description;
            }
        }
        return "Failed. Try again.";
    }
   
    // Function to apply bonuses based on mastery
    void ApplyMasteryBonus(Skill& skill, double precision) {
        // Example bonus application: Increase bonusValue based on precision
        // You can customize this based on your game's mechanics
        double bonusMultiplier = 0.0;
       
        if (precision >= 98.0) {
            bonusMultiplier = 0.5;  // Arch-Master
        }
        else if (precision >= 95.0) {
            bonusMultiplier = 0.4;  // Master
        }
        else if (precision >= 90.0) {
            bonusMultiplier = 0.3;  // Aimed
        }
        else if (precision >= 82.0) {
            bonusMultiplier = 0.25; // Very Good
        }
        else if (precision >= 75.0) {
            bonusMultiplier = 0.2;  // Good
        }
        else if (precision >= 50.0) {
            bonusMultiplier = 0.15; // Correct
        }
       
        skill.bonusValue += skill.baseValue * bonusMultiplier;
        std::cout << "Applied bonus: +" << (skill.baseValue * bonusMultiplier) << " to " << skill.name << "\n";
    }
};


Utility Function for Precision Calculation


// Function to simulate precision calculation based on class and shape
double CalculatePrecision(ClassType classType, int shapeNumber) {
    // In a real scenario, this would be based on the player's performance in the mini-game
    // For simulation, we'll generate a random precision based on class and shape
    // Different classes might have different average precision ranges
    double basePrecision = 50.0; // Base average precision
   
    switch (classType) {
        case ClassType::Berserker:
            basePrecision = 60.0;
            break;
        case ClassType::Knight:
            basePrecision = 65.0;
            break;
        case ClassType::Gladiator:
            basePrecision = 70.0;
            break;
        case ClassType::Hunter:
            basePrecision = 75.0;
            break;
        case ClassType::Mage:
            basePrecision = 68.0;
            break;
        case ClassType::Priest:
            basePrecision = 72.0;
            break;
        case ClassType::Druid:
            basePrecision = 74.0;
            break;
        case ClassType::GuildLeader:
            basePrecision = 80.0;
            break;
        default:
            basePrecision = 60.0;
    }
   
    // Simulate precision with some randomness
    double precision = basePrecision + ((rand() % 21) - 10); // ±10% variance
    if (precision < 0.0) precision = 0.0;
    if (precision > 100.0) precision = 100.0;
    return precision;
}


sposób wywoływania
int main() {
    // Seed the random number generator
    srand(static_cast<unsigned int>(time(0)));
   
    // Create a character
    Character arin("Arin", ClassType::Berserker, 1000.0);
   
    // Add skills to the character
    arin.skills.emplace_back("Power Strike", SkillCategory::Offensive, 10.0);
    arin.skills.emplace_back("Shield Block", SkillCategory::Defensive, 8.0);
    arin.skills.emplace_back("Battle Cry", SkillCategory::Support, 5.0);
   
    // Create a SkillTrainer
    SkillTrainer trainer;
   
    // Simulate training a skill
    int skillToTrain = 0; // Index of "Power Strike"
    double precision = CalculatePrecision(arin.classType, 1); // Shape number can be varied
   
    std::cout << "Attempting to train skill '" << arin.skills[skillToTrain].name << "' with precision " << precision << "%.\n";
   
    bool success = trainer.TrainSkill(arin, skillToTrain, precision);
   
    if (success) {
        std::cout << "Training successful!\n";
    } else {
        std::cout << "Training failed. Try again.\n";
    }
   
    // Display updated skill stats
    Skill& trainedSkill = arin.skills[skillToTrain];
    std::cout << "Skill: " << trainedSkill.name << "\n";
    std::cout << "Level: " << trainedSkill.level << "\n";
    std::cout << "Bonus Value: " << trainedSkill.bonusValue << "\n";
    std::cout << "Upgrade Count: " << trainedSkill.upgradeCount << "\n";
    std::cout << "Remaining Gold: " << arin.gold << "\n";
   
    return 0;
}
```
